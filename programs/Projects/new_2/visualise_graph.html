<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8"/>
  <title>Sigma.js + 全エッジラベル色分け（再帰ラベル抽出）＋凡例＋ラベル反発配置</title>
  <style>
    body, html { margin:0; padding:0; }
    #container { position:relative; width:100vw; height:100vh; background:#fff; }
    #sigma-container, #label-canvas { position:absolute; top:0; left:0; width:100%; height:100%; }
    #label-canvas { pointer-events:none; }
    #legend-container {
      position:absolute; top:10px; left:10px;
      background:rgba(255,255,255,0.9); padding:8px;
      border:1px solid #ccc; border-radius:4px;
      font-size:12px; max-height:200px; overflow-y:auto; z-index:2;
    }
    .legend-item { display:flex; align-items:center; margin-bottom:4px; }
    .legend-color-box { width:12px; height:12px; margin-right:6px; border:1px solid #999; }
  </style>
</head>
<body>
  <div id="container">
    <div id="sigma-container"></div>
    <canvas id="label-canvas"></canvas>
    <div id="legend-container"><strong>エッジラベル凡例</strong></div>
  </div>

  <script type="module">
    import Graph        from 'https://cdn.skypack.dev/graphology@0.21.1';
    import Sigma        from 'https://cdn.skypack.dev/sigma@2.3.0';
    import forceAtlas2  from 'https://cdn.skypack.dev/graphology-layout-forceatlas2';

    (async () => {
      // 1) JSON読み込み
      const URL  = '/dataset/graphs/case_086/third_joint_graph.json';
      const data = await (await fetch(URL)).json();

      // 2) グラフ作成
      const graph = new Graph({ type:'directed', multi:true });
      data.nodes.forEach(n =>
        graph.addNode(String(n.id), {
          x:     Math.random(),
          y:     Math.random(),
          size:  (n.size ?? 1) * 3,
          label: n.label || String(n.id),
          color: n.color || '#66a'
        })
      );

      // 3) 再帰的ラベル抽出関数
      function extractLabel(e) {
        function findLabel(obj) {
          if (!obj || typeof obj !== 'object') return null;
          for (const key of Object.keys(obj)) {
            if (/label/i.test(key) && typeof obj[key] === 'string' && obj[key].trim()) {
              return obj[key].trim();
            }
          }
          for (const key of Object.keys(obj)) {
            const found = findLabel(obj[key]);
            if (found) return found;
          }
          return null;
        }
        return findLabel(e) || '';
      }

      // 4) 全エッジラベル収集
      const allLabels = new Set();
      data.edges.forEach(e => allLabels.add(extractLabel(e)));
      const uniqueLabels = Array.from(allLabels);

      // 5) カラーマップ作成
      const palette = [
        '#1f77b4','#ff7f0e','#2ca02c','#d62728','#9467bd',
        '#8c564b','#e377c2','#7f7f7f','#bcbd22','#17becf'
      ];
      const edgeColorMap = {};
      uniqueLabels.forEach((lbl, i) => {
        edgeColorMap[lbl] = palette[i % palette.length];
      });

      // 6) 凡例描画
      const legend = document.getElementById('legend-container');
      uniqueLabels.forEach(lbl => {
        const item = document.createElement('div');
        item.className = 'legend-item';
        const box = document.createElement('span');
        box.className = 'legend-color-box';
        box.style.background = edgeColorMap[lbl];
        const text = document.createElement('span');
        text.textContent = lbl || '(無名)';
        item.append(box, text);
        legend.appendChild(item);
      });

      // 7) エッジ追加
      data.edges.forEach(e => {
        const lbl = extractLabel(e);
        graph.addEdge(
          String(e.source),
          String(e.target),
          {
            label: lbl,
            size:  (e.size ?? 0.5) * 2,
            color: edgeColorMap[lbl]
          }
        );
      });

      // 8) ForceAtlas2 レイアウト
      forceAtlas2.assign(graph, {
        settings: { gravity:1, scalingRatio:10 },
        iterations: 100
      });

      // 9) Sigma 描画
      const renderer = new Sigma(graph, document.getElementById('sigma-container'), {
        renderNodeLabels: false,
        renderEdgeLabels: false
      });

      // 10) ラベル用 Canvas 準備
      const canvas = document.getElementById('label-canvas');
      const ctx    = canvas.getContext('2d');
      function resize() {
        const d = renderer.getDimensions();
        canvas.width  = d.width;
        canvas.height = d.height;
      }
      window.addEventListener('resize', resize);
      resize();

      // 11) ラベル反発配置＆描画
      function drawLabels() {
        ctx.clearRect(0,0,canvas.width,canvas.height);
        const cam = renderer.getCamera();
        const fontSize = 14;
        ctx.font = `${fontSize}px sans-serif`;
        ctx.textBaseline = 'bottom';
        ctx.fillStyle = '#000';

        const labelsData = data.nodes.map(n => {
          const disp = renderer.getNodeDisplayData(String(n.id));
          const px = cam.x(disp.x), py = cam.y(disp.y) - disp.size - 4;
          const text = n.label || String(n.id);
          const w = ctx.measureText(text).width, h = fontSize;
          return { text, x:px, y:py, w, h, vx:0, vy:0 };
        });

        for (let it = 0; it < 10; it++) {
          for (let i = 0; i < labelsData.length; i++) {
            for (let j = i + 1; j < labelsData.length; j++) {
              const a = labelsData[i], b = labelsData[j];
              const ax = a.x + a.w/2, ay = a.y - a.h/2;
              const bx = b.x + b.w/2, by = b.y - b.h/2;
              const dx = bx - ax, dy = by - ay;
              const overlapX = (a.w + b.w)/2 - Math.abs(dx);
              const overlapY = (a.h + b.h)/2 - Math.abs(dy);
              if (overlapX > 0 && overlapY > 0) {
                const dist = Math.hypot(dx,dy) || 1;
                const ux = dx/dist, uy = dy/dist, force = 1;
                a.vx -= ux*force; a.vy -= uy*force;
                b.vx += ux*force; b.vy += uy*force;
              }
            }
          }
          labelsData.forEach(l => {
            l.x += l.vx; l.y += l.vy;
            l.vx *= 0.6; l.vy *= 0.6;
          });
        }

        labelsData.forEach(l => {
          ctx.fillText(l.text, l.x, l.y);
        });
      }
      renderer.on('render', drawLabels);
      drawLabels();
    })().catch(console.error);
  </script>
</body>
</html>
